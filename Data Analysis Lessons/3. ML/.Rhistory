as.list(bc$Cell.size)
as.numeric(bc$Cell.shape)
as.numeric(bc$Cell.size)
fmla.gam <- (Cell.size ~ s(Cell.shape))
# Fit the GAM Model
model.gam <- gam(fmla.gam, data = bc, family = gaussian)
as.numeric(bc$Cell.shape)
as.numeric(bc$Cell.size)
class(bc$Cell.size)
bc$Cell.shape <- as.numeric(bc$Cell.shape)
class(bc$Cell.size)
bc$Cell.shape <- as.numeric(bc$Cell.shape)
class(bc$Cell.size)
bc$Cell.shape <- as.numeric(bc$Cell.shape)
bc$Cell.size <-as.numeric(bc$Cell.size)
class(bc$Cell.size)
fmla.gam <- (Cell.size ~ s(Cell.shape))
# Fit the GAM Model
model.gam <- gam(fmla.gam, data = bc, family = gaussian)
# Call summary() on model.lin and look for R-squared
summary(model.lin)
# Call summary() on model.gam and look for R-squared
summary(model.gam)
# Call plot() on model.gam
plot(model.gam)
# Get predictions from gam model
bc$pred.gam <- as.numeric(predict(model.gam, newdata = bc))
# Gather the predictions into a "long" dataset
bc_long <- bc %>%
gather(key = modeltype, value = pred, pred.lin, pred.gam)
library(broom)
library(sigr)
library(tidyverse)
# load data for logistic regression analysis
library(survival)
library(survminer)
data(lung)
dim(lung)
# Get predictions from gam model
bc$pred.gam <- as.numeric(predict(model.gam, newdata = bc))
# Gather the predictions into a "long" dataset
bc_long <- bc %>%
gather(key = modeltype, value = pred, pred.lin, pred.gam)
# Calculate the rmse
bc_long %>%
mutate(residual = weight - pred) %>%     # residuals
group_by(modeltype) %>%                  # group by modeltype
summarize(rmse = sqrt(mean(residual^2))) # calculate the RMSE
# Compare the predictions against actual weights on the test data
bc_long %>%
ggplot(aes(x = Time)) +                          # the column for the x axis
geom_point(aes(y = weight)) +                    # the y-column for the scatterplot
geom_point(aes(y = pred, color = modeltype)) +   # the y-column for the point-and-line plot
geom_line(aes(y = pred, color = modeltype, linetype = modeltype)) + # the y-column for the point-and-line plot
scale_color_brewer(palette = "Dark2")
model.lin <- glm(Cell.size ~ Cell.shape)
model.lin <- glm(Cell.size ~ Cell.shape, data = bc)
# Call summary() on model.lin and look for R-squared
summary(model.lin)
# Get predictions from gam model
bc$pred.gam <- as.numeric(predict(model.gam, newdata = bc))
# Gather the predictions into a "long" dataset
bc_long <- bc %>%
gather(key = modeltype, value = pred, pred.lin, pred.gam)
bc$pred.lin <- as.numeric(predict(model.lin, newdata = bc))
# Gather the predictions into a "long" dataset
bc_long <- bc %>%
gather(key = modeltype, value = pred, pred.lin, pred.gam)
# Calculate the rmse
bc_long %>%
mutate(residual = weight - pred) %>%     # residuals
group_by(modeltype) %>%                  # group by modeltype
summarize(rmse = sqrt(mean(residual^2))) # calculate the RMSE
# Calculate the rmse
bc_long %>%
mutate(residual = Cell.size - pred) %>%     # residuals
group_by(modeltype) %>%                  # group by modeltype
summarize(rmse = sqrt(mean(residual^2))) # calculate the RMSE
# Compare the predictions against actual weights on the test data
bc_long %>%
ggplot(aes(x = Cell.size)) +                          # the column for the x axis
geom_point(aes(y = Cell.shape)) +                    # the y-column for the scatterplot
geom_point(aes(y = pred, color = modeltype)) +   # the y-column for the point-and-line plot
geom_line(aes(y = pred, color = modeltype, linetype = modeltype)) + # the y-column for the point-and-line plot
scale_color_brewer(palette = "Dark2")
fread(url)
# get the data
url <- "https://s3.amazonaws.com/capitalbikeshare-data/2010-capitalbikeshare-tripdata.zip"
fread(url)
data.table::fread(url)
bikes <- data.table::fread(url)
bikes <- read_csv(url)
View(bikes)
bikes <- read.table(url)
View(bikes)
bikes <- GET(url)
bikes <- readxl::read_excel(url)
# get the data
url <- "https://archive.ics.uci.edu/ml/machine-learning-databases/00275/Bike-Sharing-Dataset.zip"
# get the data
download.file("http://api.worldbank.org/v2/en/country/gbr?downloadformat=csv",
temp)
# get the data
tmp <- tempfile()
download.file("http://api.worldbank.org/v2/en/country/gbr?downloadformat=csv",
tmp)
download.file("https://archive.ics.uci.edu/ml/machine-learning-databases/00275/Bike-Sharing-Dataset.zip",
tmp)
bikes <- unz(tmp, "hour.csv")
bikedat <- read.table(bikes, header = T, sep = ",")
View(BreastCancer)
View(bikedat)
str(bikedat)
# bikedat is in the workspace
str(bikedat)
# Random seed to reproduce results
seed
# the outcome column
(outcome <- "cnt")
# The input variables
(vars <- c("hr", "holiday", "workingday", "weathersit", "temp", "atemp", "hum", "windspeed"))
# Create the formula string for bikes rented as a function of the inputs
(fmla <- paste(outcome, "~", paste(vars, collapse = " + ")))
# Load the package ranger
library(ranger)
install.packages("ranger")
# Load the package ranger
library(ranger)
# Fit and print the random forest model.
(bike_model_rf <- ranger(fmla,
bikedat,
num.trees = 500,
respect.unordered.factors = "order",
seed = seed))
# Create the formula string for bikes rented as a function of the inputs
(fmla <- paste(outcome, "~", paste(vars, collapse = " + ")))
# Load the package ranger
library(ranger)
# Fit and print the random forest model.
(bike_model_rf <- ranger(fmla,
bikedat,
num.trees = 500,
respect.unordered.factors = "order",
seed = seed))
# Random seed to reproduce results
seed
# Random seed to reproduce results
seed <- set.seed(1)
# Fit and print the random forest model.
(bike_model_rf <- ranger(fmla,
bikedat,
num.trees = 500,
respect.unordered.factors = "order",
seed = seed))
# Random seed to reproduce results
seed <- set.seed(423563)
# Fit and print the random forest model.
(bike_model_rf <- ranger(fmla,
bikedat,
num.trees = 500,
respect.unordered.factors = "order",
seed = seed))
install.packages("kableExtra")
tmp <- tempfile()
download.file("https://archive.ics.uci.edu/ml/machine-learning-databases/00275/Bike-Sharing-Dataset.zip",
tmp)
bikes <- unz(tmp, "hour.csv")
bikedat <- read.table(bikes, header = T, sep = ",")
(bike_model_rf <- ranger(fmla,
bikedat,
num.trees = 500,
respect.unordered.factors = "order",
seed = seed))
detach("package:base", unload = TRUE)
here::here()
here::here("Data Analysis Lessons")
here::here("Data Analysis Lessons", "3. ML", "ws_customers.rds")
dist_customers <- readRDS(here::here("Data Analysis Lessons", "3. ML", "ws_customers.rds"))
dist_customers
# Calculate Euclidean distance between customers
dist_customers <- dist(customers_spend)
customers_spend <- readRDS(here::here("Data Analysis Lessons", "3. ML", "ws_customers.rds"))
# Calculate Euclidean distance between customers
dist_customers <- dist(customers_spend)
# Generate a complete linkage analysis
hc_customers <- hclust(dist_customers, method = "complete")
# Plot the dendrogram
plot(hc_customers)
# Create a cluster assignment vector at h = 15000
clust_customers <- cutree(hc_customers, h = 15000)
# Generate the segmented customers data frame
segment_customers <- mutate(customers_spend, cluster = clust_customers)
library(tidyverse)
# Generate the segmented customers data frame
segment_customers <- mutate(customers_spend, cluster = clust_customers)
library(tidyverse)
# Generate the segmented customers data frame
segment_customers <- mutate(customers_spend, cluster = clust_customers)
# Explore wholesale customer clusters
dist_customers <- dist(customers_spend)
hc_customers <- hclust(dist_customers)
clust_customers <- cutree(hc_customers, h = 15000)
segment_customers <- mutate(customers_spend, cluster = clust_customers)
# Count the number of customers that fall into each cluster
count(segment_customers, cluster)
# Color the dendrogram based on the height cutoff
dend_customers <- as.dendrogram(hc_customers)
dend_colored <- color_branches(dend_customers, h = 15000)
# Cutting the tree
library(dendextend)
# Count the number of customers that fall into each cluster
count(segment_customers, cluster)
# Color the dendrogram based on the height cutoff
dend_customers <- as.dendrogram(hc_customers)
dend_colored <- color_branches(dend_customers, h = 15000)
# Plot the colored dendrogram
plot(dend_colored)
# Calculate the mean for each category
segment_customers %>%
group_by(cluster) %>%
summarise_all(funs(mean(.)))
# Calculate the mean for each category
segment_customers %>%
group_by(cluster) %>%
summarise_all(funs(mean(.)))
# Build a kmeans model
model_km2 <- kmeans(lineup, centers = 2)
# Build a kmeans model
model_km2 <- kmeans(starwars_dummy, centers = 2)
starwars<- na.omit(starwars)
# load data for cluster analysis
mtcars
library(dummies)
starwars_dummy <- dummy.data.frame(starwars)
# Build a kmeans model
model_km2 <- kmeans(starwars_dummy, centers = 2)
library(dummies)
starwars_dummy <- dummy.data.frame(starwars)
# Perform the hierarchical clustering using the complete linkage
dist_skin_color <- dist(starwars_dummy$skin_colorblue, method = "binary")
# Visualizing the Dendrogram
dist_hair <- dist(starwars_dummy$skin_colorblue)
###DEMO for Unsupervised Learning: cluster analysis###
# Lessons are adapted and organized by Noushin Nabavi, PhD. (adapted from DataCamp Courses)
## distances for hierarchical and k-means clustering
# load data for cluster analysis
mtcars
starwars<- na.omit(starwars)
# Euclidean distance between obervations when they are continuous
dist(mtcars$mpg)
# scaling when working with euclidean distance observations
mpg_s <- scale(mtcars$mpg)
dist(mpg_s)
# Measuring distance for categorical data
library(dummies)
starwars_dummy <- dummy.data.frame(starwars)
# Perform the hierarchical clustering using the complete linkage
dist_skin_color <- dist(starwars_dummy$skin_colorblue, method = "binary")
#-------------------------------------------------------------------------------
# Hierarchical clustering in R: capturing K clusters
# Calculate the assignment vector with a k of 2
skincol_cluster <- hclust(dist_skin_color, method = "complete")
clusters_k2 <- cutree(skincol_cluster, k = 2)
# Create a new data frame storing these results
starwars_k2_complete <- mutate(starwars_dummy, cluster = clusters_k2)
# Count the cluster assignments
count(starwars_k2_complete, cluster)
# Plot the positions of the players and color them using their cluster
ggplot(starwars_k2_complete, aes(x = skin_colorblue, y = skin_colorpale, color = factor(cluster))) +
geom_point()
#-------------------------------------------------------------------------------
# Visualizing the Dendrogram
dist_hair <- dist(starwars_dummy$skin_colorblue)
# Generate hclust for complete, single & average linkage methods
hc_complete <- hclust(dist_hair, method = "complete")
hc_single <- hclust(dist_hair, method = "single")
hc_average <- hclust(dist_hair, method = "average")
# Plot & Label the 3 Dendrograms Side-by-Side
# Hint: To see these Side-by-Side run the 4 lines together as one command
par(mfrow = c(1,3))
plot(hc_complete, main = 'Complete Linkage')
plot(hc_single, main = 'Single Linkage')
plot(hc_average, main = 'Average Linkage')
#-------------------------------------------------------------------------------
# Cutting the tree
library(dendextend)
dist_hair <- dist(starwars_dummy$skin_colorblue, method = "euclidean")
hc_hair <- hclust(dist_hair, method = "complete")
# Create a dendrogram object from the hclust variable
dend_hair <- as.dendrogram(hc_hair)
# Plot the dendrogram
plot(dend_hair)
# Color branches by cluster formed from the cut at a height of 20 & plot
dend_20 <- color_branches(dend_hair, h = 20)
# Plot the dendrogram with clusters colored below height 20
plot(dend_20)
# Color branches by cluster formed from the cut at a height of 40 & plot
dend_40 <- color_branches(dend_hair, h = 40)
# Plot the dendrogram with clusters colored below height 40
plot(dend_40)
# Exploring the branches cut from the tree
# Calculate the assignment vector with a h of 20
clusters_h20 <- cutree(hc_hair, h = 20)
# Create a new data frame storing these results
lineup_h20_complete <- mutate(starwars_dummy, cluster = clusters_h20)
# Calculate the assignment vector with a h of 40
clusters_h40 <- cutree(hc_hair, h = 40)
# Create a new data frame storing these results
lineup_h40_complete <- mutate(starwars_dummy, cluster = clusters_h40)
# Plot the positions of the players and color them using their cluster for height = 20
ggplot(lineup_h20_complete, aes(x = skin_colorblue, y = skin_colorpale, color = factor(cluster))) +
geom_point()
# Plot the positions of the players and color them using their cluster for height = 40
ggplot(lineup_h40_complete, aes(x = skin_colorblue, y = skin_colorpale, color = factor(cluster))) +
geom_point()
#-------------------------------------------------------------------------------
# load libraries
library(here)
library(tidyverse)
# load data
customers_spend <- readRDS(here::here("Data Analysis Lessons", "3. ML", "ws_customers.rds"))
# Calculate Euclidean distance between customers
dist_customers <- dist(customers_spend)
# Generate a complete linkage analysis
hc_customers <- hclust(dist_customers, method = "complete")
# Plot the dendrogram
plot(hc_customers)
# Create a cluster assignment vector at h = 15000
clust_customers <- cutree(hc_customers, h = 15000)
# Generate the segmented customers data frame
segment_customers <- mutate(customers_spend, cluster = clust_customers)
# Explore wholesale customer clusters
dist_customers <- dist(customers_spend)
hc_customers <- hclust(dist_customers)
clust_customers <- cutree(hc_customers, h = 15000)
segment_customers <- mutate(customers_spend, cluster = clust_customers)
# Count the number of customers that fall into each cluster
count(segment_customers, cluster)
# Color the dendrogram based on the height cutoff
dend_customers <- as.dendrogram(hc_customers)
dend_colored <- color_branches(dend_customers, h = 15000)
# Plot the colored dendrogram
plot(dend_colored)
# Calculate the mean for each category
segment_customers %>%
group_by(cluster) %>%
summarise_all(funs(mean(.)))
#-------------------------------------------------------------------------------
# Introduction to K-means
# Build a kmeans model
model_km2 <- kmeans(starwars_dummy, centers = 2)
# Extract the cluster assignment vector from the kmeans model
clust_km2 <- model_km2$cluster
# Create a new data frame appending the cluster assignment
lineup_km2 <- mutate(lineup, cluster = clust_km2)
# Plot the positions of the players and color them using their cluster
ggplot(lineup_km2, aes(x = x, y = y, color = factor(cluster))) +
geom_point()
# Build a kmeans model
model_km2 <- kmeans(starwars_dummy, centers = 2)
# Build a kmeans model
model_km2 <- kmeans(starwars_dummy$skin_colorblue, centers = 2)
# Build a kmeans model
model_km2 <- kmeans(starwars, centers = 2)
# Build a kmeans model
model_km2 <- kmeans(starwars_dummy, centers = 2)
# Build a kmeans model
model_km2 <- kmeans(starwars_dummy$skin_colorblue, centers = 2)
# Extract the cluster assignment vector from the kmeans model
clust_km2 <- model_km2$cluster
# Create a new data frame appending the cluster assignment
lineup_km2 <- mutate(lineup, cluster = clust_km2)
# Plot the positions of the players and color them using their cluster
ggplot(lineup_km2, aes(x = x, y = y, color = factor(cluster))) +
geom_point()
starwars_dummy
as.data.frame(starwars_dummy$height, starwars_dummy$mass)
lineup <- starwars_dummy %>%
select(height, mass)
# Build a kmeans model
model_km2 <- kmeans(lineup, centers = 2)
model_km2
# Extract the cluster assignment vector from the kmeans model
clust_km2 <- model_km2$cluster
# Create a new data frame appending the cluster assignment
lineup_km2 <- mutate(lineup, cluster = clust_km2)
# Plot the positions of the players and color them using their cluster
ggplot(lineup_km2, aes(x = x, y = y, color = factor(cluster))) +
geom_point()
# Plot the positions of the players and color them using their cluster
ggplot(lineup_km2, aes(x = height, y = weight, color = factor(cluster))) +
geom_point()
# Create a new data frame appending the cluster assignment
lineup_km2 <- mutate(lineup, cluster = clust_km2)
lineup_km2
# Plot the positions of the players and color them using their cluster
ggplot(lineup_km2, aes(x = height, y = mass, color = factor(cluster))) +
geom_point()
# Build a kmeans model
model_km3 <- kmeans(lineup, centers = 3)
# Extract the cluster assignment vector from the kmeans model
clust_km3 <- model_km3$cluster
# Create a new data frame appending the cluster assignment
lineup_km3 <- mutate(lineup, cluster = clust_km3)
# Plot the positions of the players and color them using their cluster
ggplot(lineup_km3, aes(x = height, y = mass, color = factor(cluster))) +
geom_point()
library(purrr)
# Use map_dbl to run many models with varying value of k (centers)
tot_withinss <- map_dbl(1:10,  function(k){
model <- kmeans(x = lineup, centers = k)
model$tot.withinss
})
# Generate a data frame containing both k and tot_withinss
elbow_df <- data.frame(
k = 1:10,
tot_withinss = tot_withinss
)
# Use map_dbl to run many models with varying value of k (centers)
tot_withinss <- map_dbl(1:10,  function(k){
model <- kmeans(x = lineup, centers = k)
model$tot.withinss
})
# Generate a data frame containing both k and tot_withinss
elbow_df <- data.frame(
k = 1:10,
tot_withinss = tot_withinss
)
# Plot the elbow plot
ggplot(elbow_df, aes(x = k, y = tot_withinss)) +
geom_line() +
scale_x_continuous(breaks = 1:10)
library(cluster)
library(cluster)
# Generate a k-means model using the pam() function with a k = 2
pam_k2 <- pam(lineup, k = 2)
# Plot the silhouette visual for the pam_k2 model
plot(silhouette(pam_k2))
# Generate a k-means model using the pam() function with a k = 3
pam_k3 <- pam(lineup, k = 3)
# Plot the silhouette visual for the pam_k3 model
plot(silhouette(pam_k3))
customers_spend
segment_customers
# Use map_dbl to run many models with varying value of k
sil_width <- map_dbl(2:10,  function(k){
model <- pam(x = customers_spend, k = k)
model$silinfo$avg.width
})
# Generate a data frame containing both k and sil_width
sil_df <- data.frame(
k = 2:10,
sil_width = sil_width
)
# Plot the relationship between k and sil_width
ggplot(sil_df, aes(x = k, y = sil_width)) +
geom_line() +
scale_x_continuous(breaks = 2:10)
set.seed(42)
# Build a k-means model for the customers_spend with a k of 2
model_customers <- kmeans(customers_spend, centers = 2)
# Extract the vector of cluster assignments from the model
clust_customers <- model_customers$cluster
# Build the segment_customers data frame
segment_customers <- mutate(customers_spend, cluster = clust_customers)
# Calculate the size of each cluster
count(segment_customers, cluster)
# Calculate the mean for each category
segment_customers %>%
group_by(cluster) %>%
summarise_all(funs(mean(.)))
occupational_wage <- readRDS(here::here("Data Analysis Lessons", "3. ML", "occupation_wage.rds"))
occupational_wage
oes <- readRDS(here::here("Data Analysis Lessons", "3. ML", "occupation_wage.rds"))
# Calculate Euclidean distance between the occupations
dist_oes <- dist(oes, method = 'euclidean')
# Generate an average linkage analysis
hc_oes <- hclust(dist_oes, method = 'average')
# Create a dendrogram object from the hclust variable
dend_oes <- as.dendrogram(hc_oes)
# Plot the dendrogram
plot(dend_oes)
# Color branches by cluster formed from the cut at a height of 100000
dend_colored <- color_branches(dend_oes, h = 100000)
# Plot the colored dendrogram
plot(dend_colored)
# Plot the colored dendrogram
plot(dend_colored)
library(tibble)
library(tidyr)
# Use rownames_to_column to move the rownames into a column of the data frame
df_oes <- rownames_to_column(as.data.frame(oes), var = 'occupation')
# Create a cluster assignment vector at h = 100,000
cut_oes <- cutree(hc_oes, h = 100000)
# Generate the segmented the oes data frame
clust_oes <- mutate(df_oes, cluster = cut_oes)
# Create a tidy data frame by gathering the year and values into two columns
gathered_oes <- gather(data = clust_oes,
key = year,
value = mean_salary,
-occupation, -cluster)
# Plot the relationship between mean_salary and year and color the lines by the assigned cluster
ggplot(gathered_oes, aes(x = year, y = mean_salary, color = factor(cluster))) +
geom_line(aes(group = occupation))
# Plot the elbow plot
ggplot(elbow_df, aes(x = k, y = tot_withinss)) +
geom_line() +
scale_x_continuous(breaks = 1:10)
# Plot the relationship between k and sil_width
ggplot(sil_df, aes(x = k, y = sil_width)) +
geom_line() +
scale_x_continuous(breaks = 2:10)
